/* factorial.c */

/* generated by GNU MARST -- Algol-to-C Translator, Version 2.7 */
/* Tue Apr  9 22:03:44 2024 */
/* source file: factorial.alg */
/* object file: factorial.c */

#include "algol.h"

extern struct desc main_program_0 /* program */ (void);

static struct desc factorial_3 /* local integer procedure */
(     struct arg /* n: by name integer */
);

extern struct desc outinteger_0 /* builtin void procedure */
(     struct arg /* channel: by value integer */,
      struct arg /* int: by value integer */
);

extern struct desc outstring_0 /* builtin void procedure */
(     struct arg /* channel: by value integer */,
      struct arg /* str: by name string */
);

struct dsa_main_program_0
{     /* procedure main_program (level 0) declared at line 1 */
      char *proc;
      char *file;
      int line;
      struct dsa *parent;
      struct dsa *vector[0+1];
      /* level of innermost block = 3 */
      struct mem *old_top_0;
      struct mem *new_top_0;
      struct mem *old_top_1;
      struct mem *new_top_1;
      struct mem *old_top_2;
      struct mem *new_top_2;
      struct mem *old_top_3;
      struct mem *new_top_3;
      /* procedure block 1 (level 0) beginning at line 1 */
      struct desc retval;
      /* local block 2 (level 1) beginning at line 1 */
      /* local block 3 (level 2) beginning at line 3 */
      /* factorial: integer procedure
         declared at line 3 and first referenced at line 9 */
      /* i: integer
         declared at line 11 and first referenced at line 12 */
      int i_3;
      /* teta_r: real
         declared at line 12 and first referenced at line 12 */
      double teta_r_3;
      /* teta_i: integer
         declared at line 12 and first referenced at line 12 */
      int teta_i_3;
      /* local block 8 (level 3) beginning at line 12 */
};

struct dsa_factorial_3
{     /* procedure factorial (level 1) declared at line 3 */
      char *proc;
      char *file;
      int line;
      struct dsa *parent;
      struct dsa *vector[1+1];
      /* level of innermost block = 3 */
      struct mem *old_top_0;
      struct mem *new_top_0;
      struct mem *old_top_1;
      struct mem *new_top_1;
      struct mem *old_top_2;
      struct mem *new_top_2;
      struct mem *old_top_3;
      struct mem *new_top_3;
      /* procedure block 4 (level 0) beginning at line 3 */
      struct desc retval;
      /* n: by name integer
         specified at line 3 and first referenced at line 7 */
      struct arg n_4;
      /* local block 5 (level 1) beginning at line 4 */
      /* local block 6 (level 2) beginning at line 5 */
      /* i: integer
         declared at line 5 and first referenced at line 7 */
      int i_6;
      /* fact: integer
         declared at line 5 and first referenced at line 6 */
      int fact_6;
      /* teta_r: real
         declared at line 7 and first referenced at line 7 */
      double teta_r_6;
      /* teta_i: integer
         declared at line 7 and first referenced at line 7 */
      int teta_i_6;
      /* local block 7 (level 3) beginning at line 7 */
};

static void _sigma_1(void)
{     /* statement following 'do' at line 7 */
      register struct dsa_factorial_3 *dsa_1 = (void *)
         global_dsa->vector[1];
      register struct dsa_main_program_0 *dsa_0 = (void *)
         global_dsa->vector[0];
      /* start of local block 7 (level 3) at line 7 */
      dsa_1->old_top_3 = stack_top;
      dsa_1->new_top_3 = stack_top;
      dsa_1->line = 8;
      dsa_1->fact_6 = dsa_1->fact_6 * dsa_1->i_6;
      pop_stack(dsa_1->old_top_3);
      /* end of block 7 */
      return;
}

struct desc factorial_3 /* local integer procedure */
(     struct arg n_4 /* by name integer */
)
{     struct dsa_factorial_3 my_dsa;
      register struct dsa_factorial_3 *dsa_1 = &my_dsa;
      register struct dsa_main_program_0 *dsa_0 = (void *)
         global_dsa->vector[0];
      my_dsa.proc = "factorial";
      my_dsa.file = "factorial.alg";
      my_dsa.line = 3;
      my_dsa.parent = active_dsa, active_dsa = (struct dsa *)&my_dsa;
      my_dsa.vector[0] = (void *)dsa_0;
      my_dsa.vector[1] = (void *)dsa_1;
      /* start of procedure block 4 (level 0) at line 3 */
      dsa_1->old_top_0 = stack_top;
      my_dsa.n_4 = n_4;
      dsa_1->new_top_0 = stack_top;
      /* start of local block 5 (level 1) at line 4 */
      dsa_1->old_top_1 = stack_top;
      dsa_1->new_top_1 = stack_top;
      dsa_1->line = 4;
      /* start of local block 6 (level 2) at line 5 */
      dsa_1->old_top_2 = stack_top;
      dsa_1->new_top_2 = stack_top;
      dsa_1->line = 6;
      dsa_1->fact_6 = 1;
      dsa_1->line = 7;
      dsa_1->line = 7;
      dsa_1->i_6 = 2;
      dsa_1->teta_i_6 = 1;
_gamma_1:
      dsa_1->line = 7;
      if ((dsa_1->i_6 - (get_int((global_dsa = dsa_1->n_4.arg2, (*(
         struct desc (*)(void))dsa_1->n_4.arg1)())))) * (
         dsa_1->teta_i_6 < 0 ? -1 : dsa_1->teta_i_6 > 0 ? +1 : 0) > 0) 
         goto _omega_1;
      global_dsa = (void *)dsa_1, _sigma_1();
      dsa_1->i_6 = dsa_1->teta_i_6 + dsa_1->i_6;
      goto _gamma_1;
_omega_1: /* element exhausted */
      dsa_1->line = 9;
      dsa_1->retval.u.int_val = dsa_1->fact_6;
      pop_stack(dsa_1->old_top_2);
      /* end of block 6 */
      pop_stack(dsa_1->old_top_1);
      /* end of block 5 */
      pop_stack(dsa_1->old_top_0);
      /* end of block 4 */
      my_dsa.retval.lval = 0;
      my_dsa.retval.type = 'i';
      active_dsa = my_dsa.parent;
      return my_dsa.retval;
}

static struct desc _thunk_1(void)
{     /* actual parameter at line 12 */
      struct desc res;
      res.lval = 0;
      res.type = 'i';
      res.u.int_val = 1;
      return res;
}

static struct desc _thunk_2(void)
{     /* actual parameter at line 12 */
      struct desc res;
      register struct dsa_main_program_0 *dsa_0 = (void *)
         global_dsa->vector[0];
      dsa_0->line = 12;
      res.lval = 1;
      res.type = 'i';
      res.u.int_ptr = &(dsa_0->i_3);
      return res;
}

static struct desc _thunk_3(void)
{     /* actual parameter at line 12 */
      struct desc res;
      register struct dsa_main_program_0 *dsa_0 = (void *)
         global_dsa->vector[0];
      dsa_0->line = 12;
      res.lval = 0;
      res.type = 'i';
      res.u.int_val = get_int((global_dsa = (void *)dsa_0, factorial_3(
         make_arg((void *)_thunk_2, dsa_0))));
      return res;
}

static void _sigma_2(void)
{     /* statement following 'do' at line 12 */
      register struct dsa_main_program_0 *dsa_0 = (void *)
         global_dsa->vector[0];
      /* start of local block 8 (level 3) at line 12 */
      dsa_0->old_top_3 = stack_top;
      dsa_0->new_top_3 = stack_top;
      dsa_0->line = 12;
      ((global_dsa = (void *)dsa_0, outinteger_0(make_arg((void *)
         _thunk_1, dsa_0), make_arg((void *)_thunk_3, dsa_0))));
      pop_stack(dsa_0->old_top_3);
      /* end of block 8 */
      return;
}

struct desc main_program_0 /* program */ (void)
{     struct dsa_main_program_0 my_dsa;
      register struct dsa_main_program_0 *dsa_0 = &my_dsa;
      my_dsa.proc = "main_program";
      my_dsa.file = "factorial.alg";
      my_dsa.line = 1;
      my_dsa.parent = active_dsa, active_dsa = (struct dsa *)&my_dsa;
      my_dsa.vector[0] = (void *)dsa_0;
      /* start of procedure block 1 (level 0) at line 1 */
      dsa_0->old_top_0 = stack_top;
      dsa_0->new_top_0 = stack_top;
      /* start of local block 2 (level 1) at line 1 */
      dsa_0->old_top_1 = stack_top;
      dsa_0->new_top_1 = stack_top;
      dsa_0->line = 1;
      /* start of local block 3 (level 2) at line 3 */
      dsa_0->old_top_2 = stack_top;
      dsa_0->new_top_2 = stack_top;
      dsa_0->line = 12;
      dsa_0->line = 12;
      dsa_0->i_3 = 1;
      dsa_0->teta_i_3 = 1;
_gamma_2:
      dsa_0->line = 12;
      if ((dsa_0->i_3 - (10)) * (dsa_0->teta_i_3 < 0 ? -1 : 
         dsa_0->teta_i_3 > 0 ? +1 : 0) > 0) goto _omega_2;
      global_dsa = (void *)dsa_0, _sigma_2();
      dsa_0->i_3 = dsa_0->teta_i_3 + dsa_0->i_3;
      goto _gamma_2;
_omega_2: /* element exhausted */
      dsa_0->line = 13;
      ((global_dsa = (void *)dsa_0, outstring_0(make_arg((void *)
         _thunk_1, dsa_0), make_arg("\n", NULL))));
      pop_stack(dsa_0->old_top_2);
      /* end of block 3 */
      pop_stack(dsa_0->old_top_1);
      /* end of block 2 */
      pop_stack(dsa_0->old_top_0);
      /* end of block 1 */
      my_dsa.retval.lval = 0;
      my_dsa.retval.type = 0;
      active_dsa = my_dsa.parent;
      return my_dsa.retval;
}

int main(void)
{     /* Algol program startup code */
      main_program_0();
      return 0;
}

/* eof */
